## 定义
> 将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是 `哈希算法`\
#### 要求
* 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；
* 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；
* 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；
* 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。
#### 鸽巢原理，又名狄利克雷抽屉原理、鸽笼原理。
> 其中一种简单的表述法为：若有n个笼子和n+1只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少2只鸽子。

## 应用
### 应用一：安全加密
> 最常用于加密的哈希算法是 `MD5`（MD5 Message-Digest Algorithm，MD5 `消息摘要算法`）和 `SHA`（Secure Hash Algorithm，`安全散列算法`）。

### 应用二：唯一标识
> `问题`：如何在海量的图库中，搜索一张图是否存在? <br/>
> `思路`：给每一个图片取一个唯一标识<br/>
> 我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识

### 应用三：数据校验
> `应用场景`：BT下载文件（基于P2P）<br/>
> `思路`：我们通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。

### 应用四：散列函数
> `目的`：数据是否能均匀地散列在各个槽中

### 应用五：负载均衡
`Tip:负载均衡:是一种计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。`<br/>
`主要作用:将大量作业合理地分摊到多个操作单元上进行执行，用于解决互联网架构中的高并发和高可用的问题。`<br/>
> `思路`：我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。

### 应用六：数据分片
> `问题`：假如我们有 1T 的日志文件，这里面记录了用户的`搜索关键词`，我们想要快速统计出每个关键词被搜索的次数，该怎么做呢？<br/>
> `难点`<br/>
> * 第一个是搜索日志很大，没办法放到一台机器的内存中
> * 如果只用一台机器来处理这么巨大的数据，处理时间会很长
> `思路`：我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。<br/>
> 为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个`搜索关键词`，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。<br/>
> 为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。<br/>
> 实际上，这里的处理过程也是 MapReduce 的基本设计思想。
#### 应用七：分布式存储
> 我们有海量的数据需要缓存，所以一个缓存机器肯定是不够的。于是，我们就需要将数据分布在多台机器上，该如何决定将哪个数据放到哪个机器上呢？<br>
> 我们可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。但是，如果数据增多，原来的 10 个机器已经无法承受了，我们就需要扩容了，比如扩到 11 个机器，这时候麻烦就来了。因为，这里并不是简单地加个机器就可以了。<br/>
> 所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生[雪崩效应](https://zh.wikipedia.org/wiki/%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94)，压垮数据库。<br/>
> 我们需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。这时候，`一致性哈希算法`就要登场了。